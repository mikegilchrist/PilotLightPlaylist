#!/usr/bin/env python3
# Date: 2025-09-17
# Version: 1.5.2
# Purpose: Scrape Pilot Light upcoming events with dry-run mode and timestamped output
# Usage: python pilotlight_scraper.py [--week_start N] [--week_stop M] [--verbose] [--dry-run]
# Input:
#   --week_start: Weeks from today to start (default: 0)
#   --week_stop:  Weeks from today to stop (default: no limit)
#   --verbose: Print parsed events to stdout
#   --dry-run: Write output files to /tmp instead of current working directory
# Output: Writes events to "upcoming_artists_<YYYY-MM-DD>.csv"
# Chat name: PilotLight Playlist - Dry Run Compatibility
# GPT Model: OpenAI o4-mini
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT

#!/usr/bin/env python3
"""
Purpose:
    Add scraped artist names to Spotify playlist(s) and handle backups.

Usage:
    ./add_to_playlist.py <filename> [--backup-only] [--dry-run] [--force] [--verbose]

Input:
    - Artist text file with one entry per line
    - Environment variables for Spotify credentials (client ID/secret)
    - Configured playlist info in config.yaml

Output:
    - Updated Spotify playlists or backups written to ./tmp-*

Date: 2025-09-16
Version: 2.1.1
Chat name: pilotlight-scraper
GPT Model: GPT-4
Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT
"""

import argparse
import os
import shutil
from datetime import datetime
from playlist_utils import init_spotify, load_config, backup_playlist, restore_playlist, update_playlist

def parse_args():
    parser = argparse.ArgumentParser(description="Update Spotify playlist from artist file.")
    parser.add_argument( "filename", nargs="?", help="Optional scraped artist file (e.g., upcoming_artists_YYYY-MM-DD.csv). If not given, run scraper to generate one."                                  
)
    parser.add_argument("--backup-only", action="store_true", help="Only back up playlists")
    parser.add_argument("--dry-run", action="store_true", help="Simulate update, write to ./tmp-* files")
    parser.add_argument("--force", "-f", action="store_true", help="Overwrite existing backup files")
    parser.add_argument("--verbose", action="store_true", help="Print detailed progress")
    return parser.parse_args()

args = parse_args()
config = load_config()

now = datetime.now().strftime("%Y-%m-%d_%H%M")

if args.backup_only or args.dry_run:
    sp = init_spotify()
    for key in ["upcoming", "recent"]:
        playlist_cfg = config["playlists"].get(key)
        if not playlist_cfg:
            continue
        title = playlist_cfg["name"]
        backup_file = f"{key}_artists-{now}.csv"

        if os.path.exists(backup_file) and not args.force:
            base, ext = os.path.splitext(backup_file)
            counter = 1
            while os.path.exists(f"{base}-{counter}{ext}"):
                counter += 1
            backup_file = f"{base}-{counter}{ext}"

        if args.verbose or args.dry_run:
            print(f"{'[DRY RUN] ' if args.dry_run else ''}Backing up: {title} âž” {backup_file}")

        if args.dry_run:
            backup_file = f"./tmp-{os.path.basename(backup_file)}"

        backup_playlist(sp, playlist_cfg["id"], backup_file)

    if args.backup_only:
        exit(0)

sp = init_spotify()

if args.dry_run:
    output_file = f"./tmp-{os.path.basename(args.filename)}"
else:
    output_file = args.filename

with open(args.filename) as f:
    artists = [line.strip() for line in f if line.strip()]

for playlist_cfg in config["playlists"]:
    update_playlist(sp, artists, playlist_cfg, output_file, dry_run=args.dry_run, verbose=args.verbose)

