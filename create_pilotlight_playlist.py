#!/usr/bin/env python3
# Date: 2025-09-17
# Version: 1.5.8
# Purpose: Create playlist by scraping Pilot Light's upcoming events with dry-run mode and timestamped output
# Usage: python create_pilotlight_playlist.py [--backup-only] [--dry-run] [--force] [--verbose] [filename]
# Input:
#   --backup-only: Only back up playlists, don't update
#   --dry-run: Write to ./tmp-* files and do not update Spotify
#   --force / -f: Overwrite existing backup files
#   --verbose: Print progress messages
#   filename: Optional artist input file (default generated by scraper if omitted)
# Output: Writes/updates Spotify playlists or simulates update and writes to local file
# Chat name: PilotLight Playlist - Filename Preprocessing
# GPT Model: OpenAI o4-mini
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT

import argparse
import os
import sys
from datetime import datetime
from playlist_utils import init_spotify, load_config, backup_playlist, update_playlist
from pilotlight_scraper import scrape_upcoming_artists

def parse_args():
    parser = argparse.ArgumentParser(description="Update Spotify playlist from artist file.")
    parser.add_argument("filename", nargs="?", help="Optional scraped artist file (e.g., upcoming-artists_YYYY-MM-DD.csv)")
    parser.add_argument("--backup-only", action="store_true", help="Only back up playlists")
    parser.add_argument("--dry-run", action="store_true", help="Simulate update, write to ./tmp-* files")
    parser.add_argument("--force", "-f", action="store_true", help="Overwrite existing backup files")
    parser.add_argument("--verbose", action="store_true", help="Print detailed progress")
    return parser.parse_args()

args = parse_args()
config = load_config()
now_dt = datetime.now()
now = now_dt.strftime("%Y-%m-%d_%H%M")
date_str = now_dt.strftime("%Y-%m-%d")

# ─────────────────────────────────────────────────────────────────────────────
# Assign default filename if not given → run scraper and use generated file
# ─────────────────────────────────────────────────────────────────────────────

# Determine output filename early                                                                                                               
if not args.filename:                                                                                                                           
    args.filename = f"upcoming-artists_{date_str}.csv"                                                                                          
                                                                                                                                                
# Adjust output path for dry-run mode                                                                                                           
if args.dry_run:                                                                                                                                
    args.filename = f"./tmp-{os.path.basename(args.filename)}"                                                                                  
                                                                                                                                                
# Run scraper only if file doesn’t already exist                                                                                                
if not os.path.exists(args.filename):                                                                                                           
    if args.verbose:                                                                                                                            
        print(f"[INFO] Scraping and saving to {args.filename}")                                                                                 
    scrape_upcoming_artists(output_path=args.filename) 

# Prepend tmp- to output path for dry run mode
#if args.dry_run:
#    args.filename = f"./tmp-{os.path.basename(args.filename)}"

# ─────────────────────────────────────────────────────────────────────────────
# Backup-only or Dry-run logic
# ─────────────────────────────────────────────────────────────────────────────
sp = init_spotify()
for key in ["upcoming", "recent"]:
    playlist_cfg = config["playlists"].get(key)
    if not playlist_cfg:
        continue

    title = playlist_cfg["name"]
    backup_file = f"playlist_{key}-artists_{now}.csv"

    if os.path.exists(backup_file) and not args.force:
        base, ext = os.path.splitext(backup_file)
        counter = 1
        while os.path.exists(f"{base}-{counter}{ext}"):
            counter += 1
        backup_file = f"{base}-{counter}{ext}"

    if args.verbose or args.dry_run:
        print(f"{'[DRY RUN] ' if args.dry_run else ''}Backing up: {title} ➔ {backup_file}")

    if args.dry_run:
        backup_file = f"./tmp-{os.path.basename(backup_file)}"

    backup_playlist(sp, playlist_cfg["id"], backup_file)

if args.backup_only:
    sys.exit(0)

# ─────────────────────────────────────────────────────────────────────────────
# Read input artist file
# ─────────────────────────────────────────────────────────────────────────────
with open(args.filename) as f:
    artists = [line.strip() for line in f if line.strip()]

# ─────────────────────────────────────────────────────────────────────────────
# Update both playlists using same source
# ─────────────────────────────────────────────────────────────────────────────
for key, playlist_cfg in config["playlists"].items():
    update_playlist(
        sp,
        artists,
        playlist_cfg,
        args.filename,
        dry_run=args.dry_run,
        verbose=args.verbose
    )
