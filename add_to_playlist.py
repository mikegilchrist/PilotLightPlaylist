#!/usr/bin/env python3
# Purpose: Sync Spotify playlists from scraped artist list with dry-run and verbose
# Usage: python add_to_playlist.py [--dry-run/-n] [--verbose/-v] artist_file
# Date: 2025-08-04
# Version: 1.12.0
# Chat name: PilotLightPlaylist Sync
# GPT Model: OpenAI o4-mini
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT

import argparse
import logging
import os
import sys
from datetime import datetime

import spotipy
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv

# CLI
parser = argparse.ArgumentParser(
    description="Sync Spotify playlists from Pilot Light artist list"
)
parser.add_argument(
    "--dry-run", "-n",
    action="store_true",
    help="Simulate only; do not modify Spotify"
)
parser.add_argument(
    "--verbose", "-v",
    action="store_true",
    help="Verbose debug output"
)
parser.add_argument(
    "artist_file",
    help="Path to scraped events file (date | BAND1, BAND2, ...)"
)
args = parser.parse_args()

dry_run = args.dry_run
level = logging.DEBUG if args.verbose else logging.INFO
logging.basicConfig(format="%(message)s", level=level)
log = logging.getLogger()

# Initialize or stub Spotify client
def init_spotify():
    load_dotenv()
    if dry_run:
        log.info("[DRY RUN] No Spotify API calls will be made.")
        class DummySp:
            def current_user(self): return {'id': 'dry_user'}
            def current_user_playlists(self, limit): return {'items': []}
            def user_playlist_create(self, user, name, public=True):
                log.info(f"[DRY RUN] Would create playlist '{name}' for user {user}")
                return {'id': 'dry_id', 'external_urls': {'spotify': 'https://open.spotify.com/playlist/dry_id'}}
            def search(self, q, type, limit=1): return {'artists': {'items': []}}
            def artist_top_tracks(self, artist_id): return {'tracks': []}
            def playlist_items(self, playlist_id): return {'items': []}
            def playlist_remove_all_occurrences_of_items(self, pid, items):
                log.info(f"[DRY RUN] Would remove {len(items)} items from {pid}")
            def playlist_add_items(self, pid, items):
                log.info(f"[DRY RUN] Would add {len(items)} items to {pid}")
        return DummySp()
    else:
        creds = SpotifyOAuth(
            client_id=os.getenv("SPOTIFY_CLIENT_ID"),
            client_secret=os.getenv("SPOTIFY_CLIENT_SECRET"),
            redirect_uri=os.getenv("SPOTIFY_REDIRECT_URI"),
            scope="playlist-modify-public playlist-modify-private"
        )
        return spotipy.Spotify(auth_manager=creds)

sp = init_spotify()

# Extract bands
def extract_band_names(fn):
    upcoming, past = [], []
    with open(fn, encoding="utf-8") as f:
        for line in f:
            parts = [p.strip() for p in line.split("|")]
            if len(parts) < 2:
                continue
            try:
                date = datetime.strptime(parts[0], "%Y-%m-%d").date()
            except ValueError:
                continue
            bands = [b.strip() for b in parts[1].split(",")]
            if date >= datetime.today().date():
                upcoming.extend(bands)
            else:
                past.extend(bands)
    return upcoming, past

# Find or create playlist
def find_or_create(title):
    user = sp.current_user()["id"]
    items = sp.current_user_playlists(limit=50)["items"]
    for pl in items:
        if pl["name"] == title:
            return pl["id"], pl["external_urls"]["spotify"]
    pl = sp.user_playlist_create(user=user, name=title, public=True)
    return pl["id"], pl["external_urls"]["spotify"]

# Sync helper
def sync_tracks(bands, pid):
    existing = [t["track"]["id"] for t in sp.playlist_items(pid)["items"]]
    to_add = []
    for artist in bands:
        res = sp.search(q=artist, type="artist", limit=1)
        items = res.get("artists", {}).get("items", [])
        if not items:
            continue
        aid = items[0]["id"]
        top = sp.artist_top_tracks(aid)["tracks"][:2]
        for track in top:
            tid = track["id"]
            if tid not in existing:
                to_add.append(tid)
    if to_add:
        sp.playlist_add_items(pid, to_add)

# Main

def main():
    upcoming, past = extract_band_names(args.artist_file)
    up_id, up_url = find_or_create("Pilot Light Upcoming Shows")
    rec_id, rec_url = find_or_create("Pilot Light Recent Shows")
    log.info("Syncing Upcoming...")
    sync_tracks(upcoming, up_id)
    log.info("Syncing Recent...")
    sync_tracks(past, rec_id)
    log.info("Done.\nUpcoming: %s\nRecent: %s", up_url, rec_url)

if __name__ == "__main__":
    main()
