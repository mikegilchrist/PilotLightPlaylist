#!/usr/bin/env python3
# ============================================================================
# Script:       playlist_utils.py
# Version:      2.0.0
# Date:         2026-02-17
# Purpose:      Spotify helpers: auth, config, backup, artist search, playlist update
#
# Provides init_spotify(), load_config(), backup_playlist(),
# search_artist_top_tracks(), and update_playlist().
#
# Usage:        Imported by create_pilotlight_playlist.py
# Input:        YAML config, scraped artist CSV (date,artist,price)
# Output:       Playlist backups and Spotify playlist updates
#
# Requirements:
#   - spotipy, python-dotenv, pyyaml
#
# Session:      PilotLight Playlist Fixes
# AI Model:     Claude Opus 4.6
# Attribution:  Generated by Michael Gilchrist in collaboration with
#               ClaudeAI Opus 4.6
# ============================================================================

import csv
import logging
import os

import spotipy
import yaml
from dotenv import load_dotenv
from spotipy.oauth2 import SpotifyOAuth

load_dotenv()

log = logging.getLogger(__name__)


def init_spotify():
    """Authenticate with Spotify and return a Spotipy client."""
    return spotipy.Spotify(auth_manager=SpotifyOAuth(
        scope="playlist-modify-public playlist-modify-private",
        cache_path=os.path.expanduser("~/.cache/spotify_token.json"),
    ))


def load_config(path="config.yaml"):
    """Load playlist configuration from YAML file."""
    with open(path, "r") as f:
        return yaml.safe_load(f)


def backup_playlist(sp, playlist_id, output_file):
    """Save current playlist contents to a CSV (Artist, Title, URI)."""
    tracks = []
    results = sp.playlist_items(playlist_id)
    while results:
        for item in results["items"]:
            track = item.get("track")
            if track:
                artist_names = ", ".join(a["name"] for a in track["artists"])
                title = track["name"]
                uri = track["uri"]
                tracks.append((artist_names, title, uri))
        if results.get("next"):
            results = sp.next(results)
        else:
            break

    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Artist", "Title", "URI"])
        writer.writerows(tracks)

    log.info("Backed up %d tracks -> %s", len(tracks), output_file)


def restore_playlist(sp, playlist_id, uris):
    """Replace a playlist's contents with the given track URIs."""
    sp.playlist_replace_items(playlist_id, uris[:100])
    for i in range(100, len(uris), 100):
        sp.playlist_add_items(playlist_id, uris[i:i + 100])


def search_artist_top_tracks(sp, artist_name, num_tracks=3):
    """Search Spotify for an artist and return their top tracks.

    Returns a list of (artist_name, track_title, uri) tuples, up to
    num_tracks entries.  Returns an empty list if the artist is not found.
    """
    log.debug("Searching Spotify for artist: %s", artist_name)
    try:
        results = sp.search(q=f"artist:{artist_name}", type="artist", limit=5)
    except Exception as e:
        log.warning("Spotify search failed for '%s': %s", artist_name, e)
        return []

    artists = results.get("artists", {}).get("items", [])
    if not artists:
        log.debug("  No artist match found for: %s", artist_name)
        return []

    # Pick the best match: prefer exact (case-insensitive) name match
    artist = None
    for a in artists:
        if a["name"].upper() == artist_name.upper():
            artist = a
            break
    if artist is None:
        artist = artists[0]  # fall back to top result

    artist_id = artist["id"]
    display_name = artist["name"]
    log.debug("  Matched artist: %s (id=%s)", display_name, artist_id)

    try:
        top = sp.artist_top_tracks(artist_id, country="US")
    except Exception as e:
        log.warning("Failed to get top tracks for '%s': %s", display_name, e)
        return []

    tracks = top.get("tracks", [])[:num_tracks]
    found = []
    for t in tracks:
        track_artists = ", ".join(a["name"] for a in t["artists"])
        found.append((track_artists, t["name"], t["uri"]))
        log.debug("  Track: %s - %s (%s)", track_artists, t["name"], t["uri"])

    return found


def update_playlist(sp, artist_rows, playlist_cfg, output_file,
                    dry_run=False, verbose=False, num_tracks=3):
    """Search for each artist's top tracks and update a Spotify playlist.

    Parameters
    ----------
    sp : spotipy.Spotify
        Authenticated Spotify client.
    artist_rows : list of dict
        Each dict has keys: date, artist, price (from scraped CSV).
    playlist_cfg : dict
        Must contain 'id' and 'name' keys.
    output_file : str
        Path to write the resolved Artist,Title,URI CSV.
    dry_run : bool
        If True, skip the actual Spotify playlist update.
    verbose : bool
        Unused (logging level controls verbosity), kept for API compat.
    num_tracks : int
        Number of top tracks per artist (default 3).
    """
    prefix = "[DRY RUN] " if dry_run else ""
    print(f"{prefix}Updating playlist: {playlist_cfg['name']}")

    found_tracks = []   # list of URI strings
    found_rows = []     # list of (artist, title, uri) for CSV output
    not_found = []      # artist names with no Spotify match

    seen_artists = set()
    for row in artist_rows:
        artist = row["artist"]
        # Skip duplicate artist names within the same run
        if artist.upper() in seen_artists:
            continue
        seen_artists.add(artist.upper())

        results = search_artist_top_tracks(sp, artist, num_tracks=num_tracks)
        if results:
            for (artist_name, title, uri) in results:
                found_tracks.append(uri)
                found_rows.append((artist_name, title, uri))
        else:
            not_found.append(artist)

    if not_found:
        print(f"  Artists not found on Spotify ({len(not_found)}):")
        for name in not_found:
            print(f"    - {name}")

    print(f"{prefix}Found {len(found_tracks)} tracks from "
          f"{len(seen_artists) - len(not_found)}/{len(seen_artists)} artists")

    if not dry_run and found_tracks:
        restore_playlist(sp, playlist_cfg["id"], found_tracks)
        log.info("Updated Spotify playlist: %s", playlist_cfg["name"])

    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(["Artist", "Title", "URI"])
        writer.writerows(found_rows)

    log.info("Wrote track list -> %s", output_file)
