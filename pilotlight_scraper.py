#!/usr/bin/env python3
# Purpose: Scrape Pilot Light upcoming events with refined parsing and date-stamped output
# Usage: python pilotlight_scraper.py [--week_start N] [--week_stop M] [--verbose]
# Input:
#   --week_start: Weeks from today to start (default: 0)
#   --week_stop:  Weeks from today to stop (default: no limit)
# Output: Writes events to "upcoming_artists_YYYY-MM-DD.csv"
# Date: 2025-08-04
# Version: 1.5.0
# Chat name: PilotLight Scraper Refinement
# GPT Model: OpenAI o4-mini
# Attribution: Generated by Michael Gilchrist in collaboration with ChatGPT

import argparse
import logging
import re
from datetime import datetime, timedelta

import requests
from bs4 import BeautifulSoup

parser = argparse.ArgumentParser(description="Scrape Pilot Light upcoming events")
parser.add_argument("--week_start", type=int, default=0, help="Weeks from today to start")
parser.add_argument("--week_stop",  type=int, default=-1, help="Weeks to stop (no limit if negative)")
parser.add_argument("--verbose", "-v", action="store_true", help="Enable debug output")
args = parser.parse_args()

level = logging.DEBUG if args.verbose else logging.INFO
logging.basicConfig(format="%(message)s", level=level)
log = logging.getLogger()

today      = datetime.today().date()
start_date = today + timedelta(weeks=args.week_start)
end_date   = None if args.week_stop < 0 else today + timedelta(weeks=args.week_stop)

URL            = "https://thepilotlight.com"
IGNORE_PHRASES = {"OUT SERIES", "UPDATE", "UPDATE!", "IMPROVISED MUSIC SETS"}

def parse_event(p_tag):
    for strike in p_tag.find_all("s"):
        strike.decompose()
    text = p_tag.get_text(separator="\n")
    text = text.replace("\u2013", "-").replace("\u2014", "-")
    text = re.sub(r"[ \t]+", " ", text)

    m = re.search(r"(\w+day)\s+([A-Za-z]+)\s+(\d+).*?\$(FREE|\d+)",
                  text, flags=re.IGNORECASE)
    if not m:
        return None

    month, day, price = m.group(2), m.group(3), m.group(4).upper()
    date_str = f"{month} {day} {today.year}"
    show_date = None
    for fmt in ("%b %d %Y", "%B %d %Y"):
        try:
            show_date = datetime.strptime(date_str, fmt).date()
            break
        except ValueError:
            continue
    if not show_date or show_date < start_date or (end_date and show_date > end_date):
        return None

    bands = []
    for line in text.split("\n"):
        if not line.strip() or any(ph in line.upper() for ph in IGNORE_PHRASES):
            continue
        for part in re.split(r"\bwith\b|,|/| and ", line, flags=re.IGNORECASE):
            part = part.strip()
            if re.fullmatch(r"[A-Z0-9 &]{2,}", part):
                bands.append(part)
    if not bands:
        return None

    return f"{show_date} | {', '.join(bands)} | ${price}"

resp = requests.get(URL)
resp.raise_for_status()
soup = BeautifulSoup(resp.text, "html.parser")

events = []
for p in soup.find_all("p"):
    ev = parse_event(p)
    if ev:
        log.info("Parsed event: %s", ev)
        events.append(ev)

# Always date-stamped CSV output
out_file = f"upcoming_artists_{today:%Y-%m-%d}.csv"
with open(out_file, "w", encoding="utf-8") as fp:
    for e in events:
        fp.write(e + "\n")

log.info("Wrote %d events ➔ %s", len(events), out_file)
if args.week_stop < 0:
    log.info("Suggested playlist title: Upcoming Shows")
else:
    start_lbl = start_date.strftime("%b %d")
    end_lbl   = (end_date - timedelta(days=1)).strftime("%b %d")
    log.info("Suggested playlist title: Pilot Light Shows %s–%s", start_lbl, end_lbl)
